# 변수와 가변성
러스트에서 변수는 기본적으로 불변 (immutable) 이다.
```rust
fn main() {
    let x = 10;
    x = 20; // error
}
```
변수를 가변으로 만들고 싶으면 `mut` 키워드를 사용한다.
```rust
fn main() {
    let mut x = 10;
    x = 20;
}
```

# 상수
상수는 불변 변수와 마찬가지로 값을 바꾸는 것을 허용하지 않는다. 
변수와 가장 큰 차이점은 상수는 `mut` 키워드를 사용할 수 없다. 즉 항상 불변인 값이다.
`const` 키워드로 선언을 한다. 값의 타입은 반드시 명시되어야 한다.

상수는 전역 스코프를 포함한 어떤 스코프에서도 선언이 가능하다.
상수는 런타임에서 결정되는 값으로는 설정할 수 없고 상수 표현식으로만 설정될 수 있다.

상수는 단어 사이에 밑줄을 사용하고 문자를 대문자로 쓰는 것이 관례이다.
상수는 선언된 스코프 내에서 프로그램이 종료될 때까지 모든 시간동안 유효하다.

# Shadow
러스트에서는 새 변수를 이전 변수명으로 선언할 수 있다. 이전 변수가 새 변수에 의해 가려졌다고 표현하여 shadow 라고 한다.
변수를 사용할 때 컴파일러는 새 변수를 보게된다. 똑같은 변수명과 `let` 키워드로 변수를 가릴 수 있다.

```rust
fn main() {
    let x = 10;
    let x = 10 + 10;

    {
        let x = x + 10;
        println!("{}", x); // 30
    } // 스코프 안 쪽 shadow 가 끝난다.
    
    println!("{}", x); // 20
}
```

shadowing 은 `mut` 과는 다르다. `let` 키워드 없이 변수에 값을 재할당 하려고 한다면 에러가 발생한다.
`let` 사용하면 값을 변형하면서 불변을 유지할 수 있다. 

`let` 키워드로 새로운 변수를 만드는 것이기 때문에 같은 변수명으로 다른 데이터 타입의 값을 저장할 수 있다. 

```rust
fn main() {
    let x = "abc";  // 문자열 타입
    let x = x.len(); // 숫자 타입
}
```

# 데이터 타입
러스트의 모든 값은 특정한 타입을 가진다. 러스트는 모든 변수의 타입이 컴파일 시점에 반드시 정해져 있어야한다.(statically typed)
러스트 컴파일러는 타입을 추론할 수 있는데, 타입 추론이 불가능할 경우에는 명시적으로 타입을 적어줘야한다.
```rust
fn main() {
    let guess: u32 = "42".parse().expect("Not a number");    
}
```

## 스칼라 타입 (scalar type)
스칼라 타입은 하나의 값을 표현한다. 
1. 정수
2. 부동 소수점 숫자
3. Boolean
4. 문자

### 정수형 (integer type)
정수형은 소수점이 없는 숫자이다.

| 길이 | 부호 있음 (signed) | 부호 없음 (unsigned) |
|-----|------------------|-------------------|
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch | isize | usize |

`isize` 와 `usize` 타입은 프로그램이 동작하는 컴퓨터의 아키텍처에 따라 데이터의 크기가 결정이 된다.
64-bit 아키텍처이면 64비트를, 32-bit 아키텍처이면 32비트를 갖게된다.

| 숫자 리터럴 | 예 |
|----------|-----|
| Decimal | 98_222 |
| Hex | 0xff |
| Octal | 0o77 |
| Binary | 0b1111_0000 |
| Byte(u8 only) | b'A' |

따로 데이터타입을 정하지 않고 정수를 사용한다면 기본값으로 `i32`로 선언된다.

### 부동 소수점 타입
러스트에도 소수점을 갖는 숫자인 부동 소수점(floating-point) 숫자 기본 타입이 두 가지 있다. 
부동 소수점 타입은 `f32`와 `f64`로 각각 32bit, 64bit 크기를 갖는다. 기본 타입은 `f64` 이다.

```rust
// IEEE-754 표준을 따른다.
fn main() {
    let x = 2.0;        // f64
    let y: f32 = 3.0;   // f32
}
```

`f32` 타입은 1배 수 정밀도 (single-precision) 인 부동 소수점이고, 
`f64`는 2배 수 정밀도 (double-precision) 이다.

### boolean 타입
다른 언어들처럼 `true`와 `false` 두 값을 가질 수 있다. boolean 값은 1바이트이다.

```rust
fn main() {
    let t = true;
    let f: bool = false;
}
```

### 문자타입
러스트의 `char` 언어의 가장 기본적인 알파벳 타입이다.
```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ';
}
```
`char` 타입은 작은따옴표를 쓰는 점을 주의해아한다. `char` 타입의 크기는 4바이트이며 유니코드 스칼라 값을 표현하며 ASCII보다 훨씬 더 많은 값을 표현할 수 있다.


## 복합 타입 (compound type)
복합 타입은 여러 값을 하나의 타입으로 묶을 수 있습니다. 러스트에는 튜플 (tuple)과 배열 (array) 두 가지 기본 복합 타입이 있다.

### 튜플 타입 (tuple type)
튜플은 다양한 타입의 여러 값을 묶어 하나의 복합 타입으로 만드는 일반적인 방법이다. 튜플은 고정된 크기를 갖는다. 한 번 선언되면 크기를 줄이거나 늘릴 수 없다.

괄호 안에 쉼표로 구분하여 값들의 목록을 작성하면 튜플을 만들 수 있다. 튜플 내의 각 위치는 타입을 갖고, 타입들은 서로 달라도 된다.
```rust
fn main() {
    // 타입을 명시하지 않아도 됨.
    let tup: (i32, f64, String) = (500, 6.4, "string");
}
```
튜플은 하나의 복합 요소로 취급되므로 변수 `tup`은 튜플 전체가 바인딩된다. 패턴 매칭을 하여 튜플 값을 해체하여 사용할 수 있다.

```rust
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```
tuple을 세 개의 분리된 변수 `x`, `y`, `z`로 바꾼다. 이것을 구조 해체(destructuring) 이라고 부른다.

`.` 뒤에 접근하고자 하는 값의 인덱스를 쓰는 방식으로도 튜플 요소에 접근할 수 있다.
```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
}
```
아무 값도 없는 튜플은 유닛 (unit) 이라고 한다. 이 값과 타입은 모두 `()`로 작성되고 빈 값이나 비어있는 반환 타입을 나타낸다.
표현식이 어떠한 값도 반환하지 않는다면 암묵적으로 유닛 값을 반환하게 된다.

### 배열 타입
튜플과는 달리 배열의 모든 요소는 모두 같은 타입이어야 한다. 러스트의 배열은 고정된 길이를 갖는다.

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```
힙보다는 스택에 데이터를 할당하고 싶을 때나 항상 고정된 개수의 요소로 이루어진 경우라면 배열이 유용하다.

다음과 같이 대괄호 안에 요소의 타입을 쓰고 세미콜론을 쓴 뒤 요소의 개수를 적는 식으로 배열의 타입을 작성할 수도 있다.

```rust
fn main() {
    // i32: 각 요소의 타입, 5: 배열이 5개 요소를 갖고 있음을 나타낸다.
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    
    // 모두 3으로 채워진 5개 요소를 갖게된다.
    let b = [3; 5]; // [3, 3, 3, 3, 3]
}
```
배열은 스택에 할당될 수 있는 계산 가능한 고정된 크기의 단일 메모리 뭉치이다. 
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    
    let first = a[0];
    let second = a[1];
}
```

# 함수
새로운 함수를 선언하려면 `fn` 키워드를 사용해야한다. 러스트는 함수나 변수 이름의 관례로 `snake case` 방식을 이용을 한다.

```rust
fn main() {
    println!("Hello, world");
    
    another_function();
}

fn another_function() {
    println!("Another function.");
}
```
러스트에서는 `fn` 뒤에 함수 이름과 괄호를 붙여 함수를 정의한다. 중괄호는 함수 본문의 시작과 끝을 컴파일러에게 알려준다.

러스트는 함수 위치를 고려하지 않으며, 호출하는 쪽에서 볼 수 있는 스코프 어딘가에 정의만 되어있으면 된다.

## 매개변수 (parameter)
함수는 매개변수를 갖도록 정의될 수 있으며, 함수 시그니처 (function signature) 의 일부분인 특별한 변수이다. 
함수가 매개변수를 갖고 있으면 이 매개변수에 대한 구체적인 값을 전다할 수 있다. 엄밀하게는 이러한 구체적인 값을 인수 (argument) 라고 부른다.

```rust
fn main() {
    another_function(5, 'h');
}

fn another_function(x: i32, unit_label: char) {
    println!("The measurement is: {}{}", x, unit_label);
}
```
함수 시그니처에서는 각 매개변수의 타입을 반드시 선언해야 한다. 함수의 정의에 타입 명시를 강제하면 이 함수를 다른 코드에서 사용할 때 개발자 의도한 타입을 컴파일러가 추측하지 않아도 된다.

## 구문과 표현식
함수 본문은 필요에 따라 표현식 (expression) 으로 끝나는 구문 (statement) 의 나열로 구성된다.
러스트는 표현식 기반의 언어이므로, 구문과 표현식의 구분은 러스트를 이해하는데 중요하다.
- 구문(statement): 어떤 동작을 수행하고 값을 반하지 않는 명령이다.
- 표현식(expression): 결과값을 평가한다.

`let` 키워드로 변수를 만들고 값을 할당하는 것은 구문이다.

```rust
fn main() {
    let x = 7;
    // let y = (let x = 7); // 오류 발생 // y에 바인딩 시킬 값이 존재하지 않는다.
}
```
함수 정의도 구문이다. 구문은 값을 반환하지 않는다. `let` 구문은 다른 변수에 할당하려고 하면 에러가 발생한다.
작성하는 러스트 코드의 대부분은 표현식이며, 이는 어떤 값을 평가한다. 표현식은 구문의 일부일 수 있다.
`let y = 7;` 이라는 구문에서 7은 7이라는 값을 평가하는 표현식이다. 함수를 호출하는 것도, 매크로를 호출하는 것도 표현식이다.
```rust
fn main() {
    let y = {           // 중괄호로 만들어진 새로운 스코프 블록도 표현식이다.
        let x = 3;
        x + 1       // 표현식은 종결을 나타내는 세미콜론을 쓰지 않음.
    };
    
    println!("The value of y is: {}", y)
}
```
표현식은 종결을 나타내는 세미콜론을 쓰지 않는다. 만약 표현식 끝에 세미콜론을 추가하면, 표현식은 구문으로 변경되고 값을 반환하지 않게 된다.

## 반환 값을 갖는 함수
함수는 호출한 코드에 값을 반환할 수 있다. 그 값의 타입은 `->` 뒤에 선언되어야 한다. 러스트에서 함수의 반환 값은 함수 본문의 마지막 표현식의 값과 동일하다.
`return` 키워드와 값을 지정하여 함수로부터 일찍 값을 반환할 수 있지만, 대부분 함수들은 암묵적으로 마지막 표현식 값을 반환한다.

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

5는 five 함수의 반환 값이며, 이 떄문에 반환 타입을 `i32` 로 설정한 것이다. `;` 로 함수의 마지막 표현식을 구문으로 만든다면 값이 반환되지 않고,
구문은 값을 평가하지 않기 때문에 `()` 로 표현되는 유닛 타입으로 표현된다.


# 제어 흐름문
러스트 코드의 실행 흐름을 제어하도록 해주는 가장 일반적인 재료는 `if` 표현식과 반복문이다.

## if 표현식
`if` 표현식은 여러분의 코드가 조건에 따라 분기할 수 있도록 해준다.

```rust
fn main() {
    let number = 6;
    
    if number % 4 == 0 {
        println!("4로 나누어지는 수");
    } else if number % 3 == 0 {
        println!("3으로 나누어지는 수");
    } else if number % 2 == 0 {
        println!("2로 나누어지는 수");
    } else {
        println!("4, 3, 2로 나누어지지 않는 수");
    }
}
```

모든 `if` 표현식은 `if` 라는 키워드로 시작하고 그 뒤에 조건이 온다. 
조건식은 반드시 `bool` 타입이어야 한다. 조건식이 `bool` 이 아니라면 에러가 발생한다.
Ruby나 JavaScript와 같은 언어와 달리 러스트는 boolean 타입이 아닌 값을 boolean 타입으로 자동 변환하지 않는다.
`else if` 표현식을 너무 많이 사용하면 코드가 복잡해질 수 있으므로, 표현식이 두 개 이상이면 코드를 리팩터링하는 것이 좋다.

`if` 는 표현식이기 떄문에 `let` 구문의 우변에 사용할 수 있다.
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };     // if 표현식을 계산한 결과값이 바인딩 될 것이다.
    println!("The value of number is : {}", number);
}
```

코드 블록은 블록 안의 마지막 표현식을 계산하고, 숫자는 그 자체로 표현식이다. `if` 표현식의 각 갈래의 결과값은 같은 타입이어야 한다.

## 반복문을 이용한 반복
러스트는 몇 가지 반복문(loop)을 제공하는데 이는 루프 본문의 시작부터 끝까지 수행한 뒤 다시 처음부터 수행한다.
러스트에는 `loop`, `while` 그리고 `for` 라는 세 종류의 반복문이 있다.

### loop로 코드 반복하기
`loop` 키워드는 그만두라고 명시하기 전까지 영원히 코드 블록을 반복 수행한다.
```rust
fn main() {
    let mut counter = 0;
    
    let result = loop {
        counter += 1;
        
        if counter == 10 {
            break counter * 2;
        }
    };
    
    loop {
        println!("The result is {}!", result);
    }
}
```
루프 안에 `break` 키워드를 집어 넣으면 루프를 멈춰야 하는 시점을 프로그램에게 알려줄 수 있다.
`break` 표현식 뒤에 반환하고자하는 값을 넣으면 연산의 결과를 이후에 코드에 전달할 수 있다.

만일 루프 안에 루프가 있다면, `break`와 `continue`는 해당 지점의 바로 바깥쪽 루프에 적용된다.
루프에 루프 라벨 (loop label)을 추가적으로 명시하면 `break` 나 `continue` 와 함께 이 키워드들이 
바로 바깥쪽 루프 대신 라벨이 적힌 특정한 루프에 적용되도록 할 수 있다. **루프 라벨은 반드시 작은 따옴표로 시작해야 한다.**

```rust
fn main() {
    let mut count = 0;
    
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;
        
        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 { 
                break;
            }
            if count == 2 { 
                break 'counting_up;
            }
            remaining -= 1;
        }
        
        count += 1;
    }
    println!("End count = {}", count);
}
```

### while을 이용한 조건 반복문
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}")
        
        number -= 1;
    };
    println!("LIFTOFF")
}
```
이 구조는 `loop`, `if`, `else`, `break` 를 사용할 때 필요하게 될 많은 중첩 구조를 제거하고 코드를 더 깔끔하게 만든다.
조건식이 `true`로 계산되는 동안 코드가 실행되고, 그렇지 않으면 반복문을 벗어난다.

### for를 이용한 컬렉션에 대한 반복문
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    
    for element in a {
        println!("the value is: {element}");
    }
}
```
`for` 루프를 사용하면 여러분이 배열 내 값의 개수를 변경시키더라도 수정해야 할 다른 코드를 기억해둘 필요가 없어진다.
표준 라이브러리가 제공하는 `Range` 타입을 이용하면 특정 횟수만큼의 반복문을 구현할 수 있는데, 
`Range`는 어떤 숫자에서 시작하여 다른 숫자 종료 전까지의 모든 숫자를 차례로 생성해준다.

```rust
fn main() {
    for number in (1..4).rev() { // rev 메서드는 범위값을 역순으로 만들어준다.
        println!("{}", number);
    }
    println!("LIFTOFF!!!");
    // 3! 2! 1! LIFTOFF!!!
}
```